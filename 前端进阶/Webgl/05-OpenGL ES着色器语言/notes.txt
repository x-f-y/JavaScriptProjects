GLSL ES支持单行注释和多行注释

GLSL ES支持数值类型和布尔类型，不支持字符串类型

int i = 8; // 正确
float f1 = 8; // 错误
float f2 = 8.0; // 正确
float f3 = 8.0f; // 错误（C语言中常用的像8.0f这样的表达式是不被允许的）

类型转换内置函数：
转换          函数          描述
转换为整型数   int(float)   将浮点数的小数部分删去，转换为整型数
             int(bool)    true被转换为1，false被转换为0
转换为浮点数   float(int)   将整型数转换为浮点数
             float(bool)  true被转换为1.0，false被转换为0.0
转换为布尔值   bool(int)    0被转换为false，其他非0值被转换为true
             bool(float)  0.0被转换为false，其他非0值被转换为true

矢量和矩阵类型：
类别  GLSL ES数据类型      描述
矢量  vec2、vec3、vec4    具有2、3、4个浮点数元素的矢量
     ivec2、ivec3、ivec4 具有2、3、4个整型数元素的矢量
     bvec2、bvec3、bvec4 具有2、3、4个布尔值元素的矢量
矩阵  mat2、mat3、mat4    2x2、3x3、4x4的浮点数元素的矩阵

矢量构造函数：
vec3 v3 = vec3(1.0, 0.0, 0.5); // 将v3设为(1.0, 0.0, 0.5)
vec2 v2 = vec2(v3); // 使用v3的前两个元素，将v2设置为(1.0, 0.0)
vec4 v4 = vec4(1.0); // 将v4设为(1.0, 1.0, 1.0, 1.0)
vec4 v4b = vec4(v2, v4); // 将v4b设为(1.0, 0.0, 1.0, 1.0)

矩阵构造函数（注意是列主序的）：
mat4 m4 = mat4(  1.0,  2.0,  3.0,  4.0,       // [ 1.0   5.0   9.0  13.0 ]
                 5.0,  6.0,  7.0,  8.0,       // [ 2.0   6.0  10.0  14.0 ]
                 9.0, 10.0, 11.0, 12.0,       // [ 3.0   7.0  11.0  15.0 ]
                13.0, 14.0, 15.0, 16.0  );    // [ 4.0   8.0  12.0  16.0 ]
vec2 v2_1 = vec2(1.0, 3.0);
vec2 v2_2 = vec2(2.0, 4.0);
mat2 m2_1 = mat2(v2_1, v2_2); // [ 1.0 2.0 ]
                              // [ 3.0 4.0 ]
vec4 v4 = vec4(1.0, 3.0, 2.0, 4.0);
mat2 m2_2 = mat2(v4); // [ 1.0 2.0 ]
                      // [ 3.0 4.0 ]
mat2 m2 = mat2(1.0, 3.0, v2_2); // [ 1.0 2.0 ]
                                // [ 3.0 4.0 ]
mat3 m3 = mat3(1.0); // [ 1.0 0.0 0.0 ]
                     // [ 0.0 1.0 0.0 ]
                     // [ 0.0 0.0 1.0 ]
mat4 m4b = mat4(1.0, 2.0, 3.0); // 错误，mat4对象需要16个元素

为了访问矢量或矩阵中的元素，可以使用 . 或 [] 运算符

在矢量变量名后接点运算符（.），然后接上分量名，就可以访问矢量的元素了。分量名如下：
类别              描述
x, y, z, w      用来获取顶点坐标分量
r, g, b, a      用来获取颜色分量
s, t, p, q      用来获取纹理坐标分量
备注：事实上，任何矢量的x、r或s分量都会返回第1个分量，y、g、t分量都返回第2个分量，等等。如果你愿意，可以随意交换使用它们

将（同一个集合的）多个分量名共同置于点运算符后，就可以从矢量中同时抽取出多个分量。这个过程称作混合（以xyzw集合为例）。
vec3 v3 = vec3(1.0, 2.0, 3.0);
vec2 v2;
v2 = v3.xy; // 设v2为(1.0, 2.0)
v2 = v3.yz; // 设v2为(2.0, 3.0)
v2 = v3.xz; // 设v2为(1.0, 3.0)
v2 = v3.yx; // 设v2为(2.0, 1.0)
v2 = v3.xx; // 设v2为(1.0, 1.0)
vec3 v3a;
v3a = v3.zyx; // 设v3a为(3.0, 2.0, 1.0)
聚合分量名也可以用来作为赋值表达式（=）的左值：
vec4 position = vec4(1.0, 2.0, 3.0, 4.0);
position.xw = vec2(5.0, 6.0); // position = (5.0, 2.0, 3.0, 6.0)
注意：此时的多个分量名必须属于同一个集合，比如说，不能使用v3.was

除了 . 运算符，还可以使用 [] 运算符并通过数组下标来访问矢量或矩阵的元素。注意：矩阵中的元素仍然是按照列主序读取的
mat4 m4 = mat4(  1.0,  2.0,  3.0,  4.0,
                 5.0,  6.0,  7.0,  8.0,
                 9.0, 10.0, 11.0, 12.0,
                13.0, 14.0, 15.0, 16.0  );
vec4 v4 = m4[0]; // 获取m4矩阵的第1列，即[1.0, 2.0, 3.0, 4.0]
float m23 = m4[1][2]; // 将m23设为m4的第2列中的第3个元素（7.0）
float m32 = m4[2].y; // 将m32设为m4的笫3列中的笫2个元素（10.0）
注意：这里有一个限制，那就是在 [] 中只能出现的索引值必须是常量索引值，常量索引值的定义如下：
- 整型字面量（如0或1）
- 用const修饰的全局变量或局部变量，不包含函数参数
- 循环索引
- 由前述三条中的项组成的表达式

GLSL ES支持用户自定义的类型，即结构体。使用关键字struct，将已存在的类型聚合到一起，就可以定义为结构体
和C语言不同的是，没有必要使用typedef关键字来定义结构体，因为结构体的名称会自动成为类型名
结构体有标准的构造函数，其名称与结构体名一致。构造函数参数的顺序必须与结构体定义中的成员顺序一致
在结构体变量名后跟点运算符（.），然后再加上成员名，就可以访问变量的成员
struct light {
    vec4 color;
    vec3 position;
} li;
li = light(vec4(0.0, 1.0, 0.0, 1.0), vec3(8.0, 3.0, 0.0));
vec4 my_color = li.color;
vec3 my_position = li.position;

GLSL ES支持数组类型。与JavaScript中的数组不同的是，GLSL ES只支持一维数组，而且数组对象不支持pop()和push()等操作，创建数组时也不需要使用new运算符
声明数组很简单，只需要在变量名后加上中括号和数组的长度，例如：
float floatArray[4];
vec4 vec4Array[2];
数组长度必须是大于0的整型常量表达式，如下定义：
- 整型字面量（如0或1）
- 用const修饰的全局变量或局部变量，不包括函数参数
- 由前述两条中的项组成的表达式
只有整型常量表达式和uniform变量可以被用作数组的索引值。此外，与JavaScript或C不同，数组不能在声明时被一次性地初始化，而必须显式地对每个元素进行初始化。例如：
vec4Array[0] = vec4(4.0, 3.0, 6.0, 1.0);
vec4Array[1] = vec4(3.0, 2.0, 0.0, 1.0);

取样器变量只能是uniform变量，或者需要访问纹理的函数，如texture2D()函数的参数

GLSL ES中没有switch语句

for语句的格式如下：
for(初始化表达式; 条件表达式; 循环步进表达式){
    循环体
}
例如：
for(int i = 0; i < 3; i++){
    sum += i;
}
注意：循环变量（即例中的i）只能在初始化表达式中定义。此外，for语句还有这样一些限制：
1. 只允许有一个循环变量，循环变量只能是int或float类型
2. 循环表达式必须是这种形式：i++、i--、i+=常量表达式或i-=常量表达式
3. 条件表达式必须是循环变量与整型常量的比较
4. 在循环体内，循环变量不可被赋值

discard语句只能在片元着色器中使用，表示放弃当前片元直接处理下一个片元

在GLSL ES中，不能在一个函数内部调用它本身（也就是说，递归调用是不允许的）

如果函数定义在其调用之后，那么我们必须在进行调用之前先声明该函数的规范。规范声明会预先告诉WebGL系统函数的参数、参数类型、返回值等等。例如：
float luma(vec4); // 规范声明
void main(){
    float brightness = luma(color);
}
float luma(vec4 color){...}

在GLSL ES中，可以为函数参数指定限定字，以控制参数的行为。可以将函数参数定义为：（1）传递给函数的（2）将要在函数中被赋值的（3）既是传递给函数的，也是将要在函数中被赋值的
类别          规则                               描述
in          向函数中传入值                       参数传入函数，函数内可以使用参数的值，也可以修改其值。但函数内部的修改不会影响传入的变量
const in    向函数中传入值                       参数传入函数，函数内可以使用参数的值，但不能修改
out         在函数中被赋值，并被传出               传入变量的引用，若其在函数内被修改，会影响到函数外部传入的变量
inout       传入函数，同时在函数中被赋值，并被传出   传入变量的引用，函数会用到变量的初始值，然后修改变量的值。会影响到函数外部传入的变量
<无：默认>   将一个值传给函数                      和in一样

attribute变量、uniform变量和varying变量都必须声明为全局变量
attribute变量只能出现在顶点着色器中，类型只能是float、vec2、vec3、vec4、mat2、mat3和mat4
uniform变量可以用在顶点着色器和片元着色器中，uniform变量是只读的，它可以是除了数组和结构体之外的任意类型
varying变量的任务是从顶点着色器向片元着色器传递数据。我们必须在两种着色器中声明同名、同类型的varying变量。和attribute变量一样，类型也只能是float、vec2、vec3、vec4、mat2、mat3和mat4

WebGL程序支持三种精度，其限定字分别是highp（高精度）、mediump（中精度）和lowp（低精度）。下面是声明变量精度的几个例子：
mediump float size;
highp vec4 position;
lowp vec4 color;
为每个变量都声明精度很繁琐，我们也可以使用关键字precision来声明着色器的默认精度，这行代码必须写在顶点着色器或片元着色器的顶部，其格式为：precision 精度限定字 类型名称;
precision mediump float; // 所有float类型以及相关的vec2和mat3的变量都是中精度的，比如，vec4类型变量的四个分量都是中精度的
precision highp int; // 所有整型变量都是高精度的

数据类型的的默认精度：
着色器类型       数据类型        默认精度
顶点着色器       int             highp
               float           highp
               sampler2D       lowp
               samplerCube     lowp
片元着色器       int             mediump
               float            无
               sampler2D       lowp
               samplerCube     lowp
注意：只有片元着色器中的float类型没有默认精度，需要手动指定

GLSL ES中常见的三种预处理指令：
1. #if 条件表达式
   如果条件表达式为真，执行这里
   #endif
2. #ifdef 某宏
   如果定义了某宏，执行这里
   #endif
3. #ifndef 某宏
   如果没有定义某宏，执行这里
   #endif

可以使用#define指令进行宏定义。和C语言中的宏不同，GLSL ES中的宏没有宏参数。可以使用#undef指令解除宏定义。格式如下：
#define 宏名 宏内容
#undef 宏名
可以使用#else指令配合#if，例如：
#define NUM 100
#if NUM == 100
如何宏NUM为100，执行这里
#else
否则，执行这里
#endif

预定义的内置宏
1. GL_ES：在OpenGL ES 2.0中定义为1
2. GL_FRAGMENT_PRECISION_HIGH：片元着色器支持highp精度
所以，我们可以这样使用宏来进行精度限定：
#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float; // 支持高精度，限定浮点型为高精度
#else
precision mediump float; // 不支持高精度，限定浮点型为中精度
#endif
#endif