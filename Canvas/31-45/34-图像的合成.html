<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        canvas {
            display: block;
            border: 2px solid #aaa;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="500" height="500">您的浏览器版本过低，请升级浏览器或者使用chrome打开！</canvas>
    <script>
        const canvas = document.getElementById('canvas')
        if(canvas.getContext){
            const ctx = canvas.getContext('2d')

            /**
             * 语法：ctx.globalCompositeOperation = type 设置要在绘制新形状时应用的合成操作的类型，其中type是用于标识要使用的
             * 合成或混合模式操作的字符串。可选值如下：
             *  1. source-over 默认值，在现有画布上下文之上绘制新图形
             *  2. source-in 新图形只在新图形和目标画布重叠的地方绘制。其他的都是透明的
             *  3. source-out 在不与现有画布内容重叠的地方绘制新图形
             *  4. source-atop 新图形只在与现有画布内容重叠的地方绘制
             *  5. destination-over 在现有的画布内容后面绘制新的图形
             *  6. destination-in 现有的画布内容保持在新图形和现有画布内容重叠的位置。其他的都是透明的
             *  7. destination-out 现有内容保持在新图形不重叠的地方
             *  8. destination-atop 现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的
             *  9. lighter 两个重叠图形的颜色是通过颜色值相加来确定的
             *  10. copy 只显示新图形
             *  11. xor 图像中，那些重叠和正常绘制之外的其他地方是透明的
             *  12. multiply 将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片
             *  13. screen 像素被倒转，相乘，再倒转，结果是一幅更明亮的图片
             *  14. overlay multiply和screen的结合，原本暗的地方更暗，原本亮的地方更亮
             *  15. darken 保留两个图层中最暗的像素
             *  16. lighten 保留两个图层中最亮的像素
             *  17. color-dodge 将底层除以顶层的反置
             *  18. color-burn 将反置的底层除以顶层，然后将结果反过来
             *  19. hard-light 屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了
             *  20. soft-light 用顶层减去底层或者相反来得到一个正值
             *  21. difference 一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白
             *  22. exclusion 和difference相似，但对比度较低
             *  23. hue 保留了底层的亮度（luma）和色度（chroma），同时采用了顶层的色调（hue）
             *  24. saturation 保留底层的亮度（luma）和色调（hue），同时采用顶层的色度（chroma）
             *  25. color 保留了底层的亮度（luma），同时采用了顶层的色调 (hue) 和色度 (chroma)
             *  26. luminosity 保持底层的色调（hue）和色度（chroma），同时采用顶层的亮度（luma）
             */

            function draw(type){
                ctx.clearRect(0, 0, canvas.width, canvas.height)
                ctx.globalCompositeOperation = 'source-over'
                ctx.fillStyle = "rgba(255, 0, 0, 1)";
                ctx.fillRect(100, 100, 300, 150);
                ctx.globalCompositeOperation = type
                ctx.fillStyle = "rgba(0, 255, 0, 1)";
                ctx.fillRect(100, 150, 150, 250);
                ctx.globalCompositeOperation = type
                ctx.fillStyle = "rgba(0, 0, 255, 1)";
                ctx.fillRect(200, 200, 150, 150);
            }

            draw('source-over')

            draw('source-in')

            draw('source-out')

            draw('source-atop')

            draw('destination-over')

            draw('destination-in')

            draw('destination-out')

            draw('destination-atop')
        }
    </script>
</body>
</html>