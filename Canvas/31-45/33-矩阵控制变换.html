<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        canvas {
            display: block;
            border: 2px solid #aaa;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="500" height="500">您的浏览器版本过低，请升级浏览器或者使用chrome打开！</canvas>
    <script>
        const canvas = document.getElementById('canvas')
        if(canvas.getContext){
            const ctx = canvas.getContext('2d')

            /**
             * ctx.transform(a, b, c, d, e, f) 将当前的变形矩阵乘上一个基于自身参数的矩阵
             * ctx.setTransform(a, b, c, d, e, f) 将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用transform()方法
             * ctx.resetTransform() 重置当前变形矩阵为单位矩阵，效果等同于调用ctx.setTransform(1, 0, 0, 1, 0, 0)
             * 备注：变换矩形的形式如下：
             *       a b 0
             *     [ c d 0 ]
             *       e f 1
             */

            /**
             * 插语：变换矩阵
             *  1. 位移
             *           1  0  0
             *  [x y 1] [0  1  0] = [x+dx y+dy 1] 备注：dx和dy为水平和垂直方向移动的距离
             *           dx dy 1
             *  2. 旋转
             *           cosΘ  sinΘ 0
             *  [x y 1] [-sinΘ cosΘ 0] = [x.cosΘ-y.sinΘ y.cosΘ+x.sinΘ 1] 备注：Θ为旋转的角度
             *           0     0    1
             *  3. 缩放
             *           sx 0  0
             *  [x y 1] [0  sy 0] = [x.sx y.sy 1] 备注：sx和sy为水平和垂直方向缩放的倍数
             *           0  0  1
             */

            // 下面的代码将会绘制和 位移、旋转和缩放.html 页面相同的效果
            ctx.setTransform(1, 0, 0, 1, 50, 50)
            ctx.fillRect(0, 0, 100, 100)

            const m = Math.sqrt(2) / 2
            ctx.setTransform(m, m, -m, m, 0, 0)
            ctx.fillRect(200, 100, 100, 30)

            ctx.setTransform(4, 0, 0, 2, 0, 0)
            ctx.fillRect(50, 100, 50, 100)
        }
    </script>
</body>
</html>